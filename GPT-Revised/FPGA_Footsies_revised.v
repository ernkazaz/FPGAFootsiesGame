//=======================================================
//  This code is generated by Terasic System Builder
//  — Revised to fix port/wire mis-namings and
//    properly hook up hitbox/hurtbox flags.
//=======================================================

module FPGA_Footsies(

    //////////// CLOCK //////////
    input                 CLOCK2_50,
    input                 CLOCK3_50,
    input                 CLOCK4_50,
    input                 CLOCK_50,

    //////////// SEG7 //////////
    output           [6:0] HEX0,
    output           [6:0] HEX1,
    output           [6:0] HEX2,
    output           [6:0] HEX3,
    output           [6:0] HEX4,
    output           [6:0] HEX5,

    //////////// KEY //////////
    input            [3:0] KEY,

    //////////// LED //////////
    output           [9:0] LEDR,

    //////////// SW //////////
    input            [9:0] SW,

    //////////// VGA //////////
    output                VGA_BLANK_N,
    output           [7:0] VGA_B,
    output                VGA_CLK,
    output           [7:0] VGA_G,
    output                VGA_HS,
    output           [7:0] VGA_R,
    output                VGA_SYNC_N,
    output                VGA_VS
);

    // ----------------------------------------------------------------
    // 1) Clock generators
    // ----------------------------------------------------------------
    wire clk_25MHz;
    wire clk_60MHz;

    Clock_Divider #(.division(2)) clock_vga (
        .clk_in    (CLOCK_50),
        .clk_bypass(1'b0),
        .button    (1'b0),
        .reset     (1'b0),
        .clk_out   (clk_25MHz)
    );

    Clock_Divider #(.division(833334)) clock_fsm (
        .clk_in    (CLOCK_50),
        .clk_bypass(SW[1]),
        .button    (~KEY[0]),
        .reset     (1'b0),
        .clk_out   (clk_60MHz)
    );


    // ----------------------------------------------------------------
    // 2) Pixel counters (from VGA driver)
    // ----------------------------------------------------------------
    wire [9:0] pixel_x;  // current X coordinate on screen (0..639)
    wire [9:0] pixel_y;  // current Y coordinate on screen (0..479)


    // ----------------------------------------------------------------
    // 3) Player 1 wires
    // ----------------------------------------------------------------
    // FSM state & flags:
    wire  [3:0] sprite_state_p1;
    wire        move_flag_p1;
    wire        directional_attack_flag_p1;
    wire        basic_attack_flag_p1;
    wire        hitbox_active_p1;
    wire        hurtbox_active_p1;
    wire        got_hit_p1;
    wire        got_blocked_p1;

    // Sprite position (upper‐left corner):
    wire [9:0] sprite_x_p1;
    wire [9:0] sprite_y_p1;

    // Hitbox coords:
    wire [9:0] hitbox_x1_p1, hitbox_x2_p1;
    wire [9:0] hitbox_y1_p1, hitbox_y2_p1;

    // Hurtbox coords:
    wire [9:0] hurtbox_x1_p1, hurtbox_x2_p1;
    wire [9:0] hurtbox_y1_p1, hurtbox_y2_p1;

    // A small “debug overlay” flag (10px‐high stripe):
    wire inside_bandana_p1;


    // ----------------------------------------------------------------
    // 4) Player 2 wires
    // ----------------------------------------------------------------
    wire  [3:0] sprite_state_p2;
    wire        move_flag_p2;
    wire        directional_attack_flag_p2;
    wire        basic_attack_flag_p2;
    wire        hitbox_active_p2;
    wire        hurtbox_active_p2;
    wire        got_hit_p2;
    wire        got_blocked_p2;

    wire [9:0] sprite_x_p2;
    wire [9:0] sprite_y_p2;

    wire [9:0] hitbox_x1_p2, hitbox_x2_p2;
    wire [9:0] hitbox_y1_p2, hitbox_y2_p2;

    wire [9:0] hurtbox_x1_p2, hurtbox_x2_p2;
    wire [9:0] hurtbox_y1_p2, hurtbox_y2_p2;

    wire inside_bandana_p2;


    // ----------------------------------------------------------------
    // 5) “sprite_pixel” primitives for color‐overlay (using P1/P2’s bounding boxes)
    // ----------------------------------------------------------------
    wire sprite_pixel_p1 = (pixel_x >= sprite_x_p1 && pixel_x < sprite_x_p1 + 64) &&
                           (pixel_y >= sprite_y_p1 && pixel_y < sprite_y_p1 + 128);

    wire sprite_pixel_p2 = (pixel_x >= sprite_x_p2 && pixel_x < sprite_x_p2 + 64) &&
                           (pixel_y >= sprite_y_p2 && pixel_y < sprite_y_p2 + 128);


    // ----------------------------------------------------------------
    // 6) “edge” signals for drawing hitbox/hurtbox outlines (if SW[0]=1)
    // ----------------------------------------------------------------
    wire switch_hitbox = SW[0];

    // P1 hurtbox‐edge:
    wire hurtbox_edge_p1 = switch_hitbox && hurtbox_active_p1 &&
        (
            (pixel_x >= hurtbox_x1_p1 && pixel_x < hurtbox_x1_p1 + 2) ||
            (pixel_x >= hurtbox_x2_p1 - 2 && pixel_x < hurtbox_x2_p1) ||
            (pixel_y >= hurtbox_y1_p1 && pixel_y < hurtbox_y1_p1 + 2) ||
            (pixel_y >= hurtbox_y2_p1 - 2 && pixel_y < hurtbox_y2_p1)
        ) &&
        (pixel_x >= hurtbox_x1_p1 && pixel_x < hurtbox_x2_p1) &&
        (pixel_y >= hurtbox_y1_p1 && pixel_y < hurtbox_y2_p1);

    // P1 hitbox‐edge:
    wire hitbox_edge_p1 = switch_hitbox && hitbox_active_p1 &&
        (
            (pixel_x >= hitbox_x1_p1 && pixel_x < hitbox_x1_p1 + 2) ||
            (pixel_x >= hitbox_x2_p1 - 2 && pixel_x < hitbox_x2_p1) ||
            (pixel_y >= hitbox_y1_p1 && pixel_y < hitbox_y1_p1 + 2) ||
            (pixel_y >= hitbox_y2_p1 - 2 && pixel_y < hitbox_y2_p1)
        ) &&
        (pixel_x >= hitbox_x1_p1 && pixel_x < hitbox_x2_p1) &&
        (pixel_y >= hitbox_y1_p1 && pixel_y < hitbox_y2_p1);

    // P2 hurtbox‐edge:
    wire hurtbox_edge_p2 = switch_hitbox && hurtbox_active_p2 &&
        (
            (pixel_x >= hurtbox_x1_p2 && pixel_x < hurtbox_x1_p2 + 2) ||
            (pixel_x >= hurtbox_x2_p2 - 2 && pixel_x < hurtbox_x2_p2) ||
            (pixel_y >= hurtbox_y1_p2 && pixel_y < hurtbox_y1_p2 + 2) ||
            (pixel_y >= hurtbox_y2_p2 - 2 && pixel_y < hurtbox_y2_p2)
        ) &&
        (pixel_x >= hurtbox_x1_p2 && pixel_x < hurtbox_x2_p2) &&
        (pixel_y >= hurtbox_y1_p2 && pixel_y < hurtbox_y2_p2);

    // P2 hitbox‐edge:
    wire hitbox_edge_p2 = switch_hitbox && hitbox_active_p2 &&
        (
            (pixel_x >= hitbox_x1_p2 && pixel_x < hitbox_x1_p2 + 2) ||
            (pixel_x >= hitbox_x2_p2 - 2 && pixel_x < hitbox_x2_p2) ||
            (pixel_y >= hitbox_y1_p2 && pixel_y < hitbox_y1_p2 + 2) ||
            (pixel_y >= hitbox_y2_p2 - 2 && pixel_y < hitbox_y2_p2)
        ) &&
        (pixel_x >= hitbox_x1_p2 && pixel_x < hitbox_x2_p2) &&
        (pixel_y >= hitbox_y1_p2 && pixel_y < hitbox_y2_p2);


    // ----------------------------------------------------------------
    // 7) Blocking flags (simple key/sw logic)
    // ----------------------------------------------------------------
    wire is_blocking_p1 = ~KEY[3];  // Player 1 blocks while KEY[3] is held
    wire is_blocking_p2 =  SW[9];   // Player 2 blocks while SW[9] is HIGH


    // ----------------------------------------------------------------
    // 8) Combine everything into one final pixel color
    // ----------------------------------------------------------------
    wire [7:0] bg_color;
    wire [7:0] color_out;

    assign color_out =
           (hitbox_edge_p1   ? 8'hE0 :  // Red
           (hurtbox_edge_p1  ? 8'hFC :  // Yellow
           (hitbox_edge_p2   ? 8'hE0 :
           (hurtbox_edge_p2  ? 8'hFC :
           (sprite_pixel_p1  ? 8'h00 :
           (sprite_pixel_p2  ? 8'h00 :
           (inside_bandana_p1? 8'hFF :
           (inside_bandana_p2? 8'hFF :
            bg_color))))))));


    // ----------------------------------------------------------------
    // 9) Instantiate Player 1 FSM
    // ----------------------------------------------------------------
    Sprite_FSM fsm_p1 (
        .clk                      (clk_60MHz),
        .reset                    (1'b0),
        .left                     (~KEY[3]),        // KEY[3] = left for P1
        .right                    (~KEY[1]),        // KEY[1] = right for P1
        .attack                   (~KEY[2]),        // KEY[2] = attack for P1
        .got_hit                  (got_hit_p1),
        .got_blocked              (got_blocked_p1),
        .state                    (sprite_state_p1),
        .move_flag                (move_flag_p1),
        .directional_attack_flag  (directional_attack_flag_p1),
        .attack_flag              (basic_attack_flag_p1)
    );


    // ----------------------------------------------------------------
    // 10) Instantiate Player 2 FSM
    // ----------------------------------------------------------------
    Sprite_FSM fsm_p2 (
        .clk                      (clk_60MHz),
        .reset                    (1'b0),
        .left                     (SW[9]),          // SW[9] = left for P2
        .right                    (SW[7]),          // SW[7] = right for P2
        .attack                   (SW[8]),          // SW[8] = attack for P2
        .got_hit                  (got_hit_p2),
        .got_blocked              (got_blocked_p2),
        .state                    (sprite_state_p2),
        .move_flag                (move_flag_p2),
        .directional_attack_flag  (directional_attack_flag_p2),
        .attack_flag              (basic_attack_flag_p2)
    );


    // ----------------------------------------------------------------
    // 11) Instantiate Player 1’s Sprite_renderer
    //     (outputs position, color, “bandana” overlay)
    // ----------------------------------------------------------------
    Sprite_renderer #(.IS_MIRRORED(0)) render1 (
        .clk           (clk_60MHz),
        .state         (sprite_state_p1),
        .pixel_x       (pixel_x),             // <— was missing
        .pixel_y       (pixel_y),             // <— was missing
        .sprite_x      (sprite_x_p1),
        .sprite_y      (sprite_y_p1),
        .sprite_color  (8'b0)                 // It is unused, can be remowed if changing state colors is unwanted.
        .inside_bandana(inside_bandana_p1)
    );


    // ----------------------------------------------------------------
    // 12) Instantiate Player 2’s Sprite_renderer (mirrored horizontally)
    // ----------------------------------------------------------------
    Sprite_renderer #(.IS_MIRRORED(1)) render2 (
        .clk           (clk_60MHz),
        .state         (sprite_state_p2),
        .pixel_x       (pixel_x),
        .pixel_y       (pixel_y),
        .sprite_x      (sprite_x_p2),
        .sprite_y      (sprite_y_p2),
        .sprite_color  (8'b0)                 // It is unused, can be remowed if changing state colors is unwanted.
        .inside_bandana(inside_bandana_p2)
    );


    // ----------------------------------------------------------------
    // 13) Instantiate Background_Renderer
    // ----------------------------------------------------------------
    Background_Renderer background (
        .pixel_x  (pixel_x),
        .pixel_y  (pixel_y),
        .bg_color (bg_color)
    );


    // ----------------------------------------------------------------
    // 14) Instantiate Player 1’s hit/hurt “boxes”
    // ----------------------------------------------------------------
    Sprite_boxes #(.IS_MIRRORED(0)) boxes1 (
        .state            (sprite_state_p1),
        .sprite_x         (sprite_x_p1),
        .sprite_y         (sprite_y_p1),
        .hitbox_x1        (hitbox_x1_p1),
        .hitbox_x2        (hitbox_x2_p1),
        .hitbox_y1        (hitbox_y1_p1),
        .hitbox_y2        (hitbox_y2_p1),
        .hurtbox_x1       (hurtbox_x1_p1),
        .hurtbox_x2       (hurtbox_x2_p1),
        .hurtbox_y1       (hurtbox_y1_p1),
        .hurtbox_y2       (hurtbox_y2_p1),
        .hitbox_active    (hitbox_active_p1),
        .hurtbox_active   (hurtbox_active_p1)
    );


    // ----------------------------------------------------------------
    // 15) Instantiate Player 2’s hit/hurt “boxes”
    // ----------------------------------------------------------------
    Sprite_Boxes #(.IS_MIRRORED(1)) boxes2 (
        .state            (sprite_state_p2),
        .sprite_x         (sprite_x_p2),
        .sprite_y         (sprite_y_p2),
        .hitbox_x1        (hitbox_x1_p2),
        .hitbox_x2        (hitbox_x2_p2),
        .hitbox_y1        (hitbox_y1_p2),
        .hitbox_y2        (hitbox_y2_p2),
        .hurtbox_x1       (hurtbox_x1_p2),
        .hurtbox_x2       (hurtbox_x2_p2),
        .hurtbox_y1       (hurtbox_y1_p2),
        .hurtbox_y2       (hurtbox_y2_p2),
        .hitbox_active    (hitbox_active_p2),
        .hurtbox_active   (hurtbox_active_p2)
    );


    // ----------------------------------------------------------------
    // 16) Collision: P1 hits P2
    // ----------------------------------------------------------------
    Collision_logic col_p1_hits_p2 (
        .attacker_hitbox_x1       (hitbox_x1_p1),
        .attacker_hitbox_x2       (hitbox_x2_p1),
        .attacker_hitbox_y1       (hitbox_y1_p1),
        .attacker_hitbox_y2       (hitbox_y2_p1),
        .attacker_hitbox_active   (hitbox_active_p1),
        .attacker_attack_flag     (basic_attack_flag_p1),
        .attacker_diratk_flag     (directional_attack_flag_p1),

        .target_hurtbox_x1        (hurtbox_x1_p2),
        .target_hurtbox_x2        (hurtbox_x2_p2),
        .target_hurtbox_y1        (hurtbox_y1_p2),
        .target_hurtbox_y2        (hurtbox_y2_p2),
        .target_hurtbox_active    (hurtbox_active_p2),
        .target_is_blocking       (is_blocking_p2),

        .got_hit_target           (got_hit_p2),
        .got_blocked_target       (got_blocked_p2)
    );


    // ----------------------------------------------------------------
    // 17) Collision: P2 hits P1
    // ----------------------------------------------------------------
    Collision_logic col_p2_hits_p1 (
        .attacker_hitbox_x1       (hitbox_x1_p2),
        .attacker_hitbox_x2       (hitbox_x2_p2),
        .attacker_hitbox_y1       (hitbox_y1_p2),
        .attacker_hitbox_y2       (hitbox_y2_p2),
        .attacker_hitbox_active   (hitbox_active_p2),
        .attacker_attack_flag     (basic_attack_flag_p2),
        .attacker_diratk_flag     (directional_attack_flag_p2),

        .target_hurtbox_x1        (hurtbox_x1_p1),
        .target_hurtbox_x2        (hurtbox_x2_p1),
        .target_hurtbox_y1        (hurtbox_y1_p1),
        .target_hurtbox_y2        (hurtbox_y2_p1),
        .target_hurtbox_active    (hurtbox_active_p1),
        .target_is_blocking       (is_blocking_p1),

        .got_hit_target           (got_hit_p1),
        .got_blocked_target       (got_blocked_p1)
    );


    // ----------------------------------------------------------------
    // 18) Finally, drive VGA outputs
    // ----------------------------------------------------------------
    vga_driver vga (
         .clock   (clk_25MHz),
         .reset   (1'b0),
         .color_in(color_out),
         .next_x  (pixel_x),
         .next_y  (pixel_y),
         .hsync   (VGA_HS),
         .vsync   (VGA_VS),
         .red     (VGA_R),
         .green   (VGA_G),
         .blue    (VGA_B),
         .sync    (VGA_SYNC_N),
         .clk     (VGA_CLK),
         .blank   (VGA_BLANK_N)
    );

endmodule
