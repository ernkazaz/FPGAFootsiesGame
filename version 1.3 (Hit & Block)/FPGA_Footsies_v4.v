
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module FPGA_Footsies(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
);

wire clk_25MHz;
wire clk_60MHz;
  
// P1
wire [2:0] sprite_state; 
wire [9:0] sprite_x, sprite_y;
wire [9:0] hitbox_x1, hitbox_x2, hitbox_y1, hitbox_y2;
wire [9:0] hurtbox_x1, hurtbox_x2, hurtbox_y1, hurtbox_y2;
wire hitbox_active, hurtbox_active;
wire sprite_pixel_p1 = (pixel_x >= sprite_x && pixel_x < sprite_x + 64) &&
                       (pixel_y >= sprite_y && pixel_y < sprite_y + 128);
//P2
wire [2:0] sprite_state_p2;
wire [9:0] sprite_x_p2, sprite_y_p2;
wire [9:0] hitbox_x1_p2, hitbox_x2_p2, hitbox_y1_p2, hitbox_y2_p2;
wire [9:0] hurtbox_x1_p2, hurtbox_x2_p2, hurtbox_y1_p2, hurtbox_y2_p2;
wire hitbox_active_p2, hurtbox_active_p2;
wire sprite_pixel_p2 = (pixel_x >= sprite_x_p2 && pixel_x < sprite_x_p2 + 64) &&
                       (pixel_y >= sprite_y_p2 && pixel_y < sprite_y_p2 + 128);
  
wire switch_hitbox = SW[0];  // Switch for hitbox on/off, can be changed   
  	
wire [9:0] pixel_x, pixel_y;

// No need for now, but inside wires will be needed for collision check //
wire inside_hurtbox_p1 = hurtbox_active &&
                         (pixel_x >= hurtbox_x1 && pixel_x < hurtbox_x2) &&
                         (pixel_y >= hurtbox_y1 && pixel_y < hurtbox_y2);

wire inside_hitbox_p1 = hitbox_active &&
                        (pixel_x >= hitbox_x1 && pixel_x < hitbox_x2) &&
                        (pixel_y >= hitbox_y1 && pixel_y < hitbox_y2);
  
wire inside_hurtbox_p2 = hurtbox_active_p2 &&
                         (pixel_x >= hurtbox_x1_p2 && pixel_x < hurtbox_x2_p2) &&
                         (pixel_y >= hurtbox_y1_p2 && pixel_y < hurtbox_y2_p2);

wire inside_hitbox_p2 = hitbox_active_p2 &&
                        (pixel_x >= hitbox_x1_p2 && pixel_x < hitbox_x2_p2) &&
                        (pixel_y >= hitbox_y1_p2 && pixel_y < hitbox_y2_p2);

// -----------------------------------------------------------------------
wire hurtbox_edge = switch_hitbox && hurtbox_active &&
    (
        (pixel_x >= hurtbox_x1 && pixel_x < hurtbox_x1 + 2) ||
        (pixel_x >= hurtbox_x2 - 2 && pixel_x < hurtbox_x2) ||
        (pixel_y >= hurtbox_y1 && pixel_y < hurtbox_y1 + 2) ||
        (pixel_y >= hurtbox_y2 - 2 && pixel_y < hurtbox_y2)
    ) &&
    (pixel_x >= hurtbox_x1 && pixel_x < hurtbox_x2) &&
    (pixel_y >= hurtbox_y1 && pixel_y < hurtbox_y2);

wire hitbox_edge = switch_hitbox && hitbox_active &&
    (
        (pixel_x >= hitbox_x1 && pixel_x < hitbox_x1 + 2) ||
        (pixel_x >= hitbox_x2 - 2 && pixel_x < hitbox_x2) ||
        (pixel_y >= hitbox_y1 && pixel_y < hitbox_y1 + 2) ||
        (pixel_y >= hitbox_y2 - 2 && pixel_y < hitbox_y2)
    ) &&
    (pixel_x >= hitbox_x1 && pixel_x < hitbox_x2) &&
    (pixel_y >= hitbox_y1 && pixel_y < hitbox_y2);

wire hurtbox_edge_p2 = switch_hitbox && hurtbox_active_p2 &&
    (
        (pixel_x >= hurtbox_x1_p2 && pixel_x < hurtbox_x1_p2 + 2) ||
        (pixel_x >= hurtbox_x2_p2 - 2 && pixel_x < hurtbox_x2_p2) ||
        (pixel_y >= hurtbox_y1_p2 && pixel_y < hurtbox_y1_p2 + 2) ||
        (pixel_y >= hurtbox_y2_p2 - 2 && pixel_y < hurtbox_y2_p2)
    );

wire hitbox_edge_p2 = switch_hitbox && hitbox_active_p2 &&
    (
        (pixel_x >= hitbox_x1_p2 && pixel_x < hitbox_x1_p2 + 2) ||
        (pixel_x >= hitbox_x2_p2 - 2 && pixel_x < hitbox_x2_p2) ||
        (pixel_y >= hitbox_y1_p2 && pixel_y < hitbox_y1_p2 + 2) ||
        (pixel_y >= hitbox_y2_p2 - 2 && pixel_y < hitbox_y2_p2)
    );
// --------------------------------------------------------------------------
wire is_blocking_p1 = ~KEY[3]  // Left is blocking at the same time, can be assigned another key.
wire is_blocking_p2 = SW[9]    // Same. Temporary key assignment.

// From FSM outputs
wire attack_flag_p1, directional_attack_flag_p1;
wire attack_flag_p2, directional_attack_flag_p2;

wire got_hit_p1, got_blocked_p1;
wire got_hit_p2, got_blocked_p2; 

wire [7:0] bg_color;
wire [7:0] color_out;

// Colors can be changed
assign color_out = hitbox_edge       ? 8'hE0 : // Red
                   hurtbox_edge      ? 8'hFC : // Yellow
                   hitbox_edge_p2    ? 8'hE0 :
                   hurtbox_edge_p2   ? 8'hFC :
                   sprite_pixel      ? 8'h00 : // Black
                   sprite_pixel_p2   ? 8'h00 :
		   inside_bandana_p1 ? 8'hFF : // White
		   inside_bandana_p2 ? 8'hFF :
                   bg_color;

Background_Renderer background (
    .pixel_x(pixel_x),
    .pixel_y(pixel_y),
    .bg_color(bg_color)
);

Clock_Divider #(.division(2)) clock_vga(
	.clk_in(CLOCK_50),
	.clk_bypass(1'b0),
	.button(1'b0),
	.reset(1'b0),
	.clk_out(clk_25MHz)
);

Clock_Divider #(.division(833334)) clock_fsm(
	.clk_in(CLOCK_50),
	.clk_bypass(SW[1]),
	.button(~KEY[0]),
	.reset(1'b0),
	.clk_out(clk_60MHz)
);

Sprite_FSM fsm_p1 (
    .clk(clk_60MHz),
    .reset(1'b0),
    .left(~KEY[3]),
    .right(~KEY[1]),
    .attack(~KEY[2]),
    .got_hit(got_hit_p1),
    .got_blocked(got_blocked_p1),
    .state(sprite_state),
    .move_flag(move_flag),
    .directional_attack_flag(directional_attack_flag),
    .attack_flag(attack_flag)
);

// The keys will be assigned again later
Sprite_FSM fsm_p2 (
    .clk(clk_60MHz),
    .reset(1'b0),
	.left(SW[9]),
	.right(SW[7]),
	.attack(SW[8]),
    .got_hit(got_hit_p2),
    .got_blocked(got_blocked_p2),
    .state(sprite_state_p2),
    .move_flag(move_flag_p2),
    .directional_attack_flag(directional_attack_flag_p2),
    .attack_flag(attack_flag_p2)
);


Sprite_renderer render1(
	.clk(clk_60MHz),
	.state(sprite_state),
	.sprite_x(sprite_x),
	.sprite_y(sprite_y),
	.sprite_color(sprite_color)
);

Sprite_renderer #(.IS_MIRRORED(1)) render2(
    .clk(clk_60MHz),
    .state(sprite_state_p2),
    .sprite_x(sprite_x_p2),
    .sprite_y(sprite_y_p2),
    .sprite_color(sprite_color_p2)
);


Sprite_boxes boxes1 (
    .state(sprite_state),
    .sprite_x(sprite_x),
    .sprite_y(sprite_y),
    .hitbox_x1(hitbox_x1),
    .hitbox_x2(hitbox_x2),
    .hitbox_y1(hitbox_y1),
    .hitbox_y2(hitbox_y2),
    .hurtbox_x1(hurtbox_x1),
    .hurtbox_x2(hurtbox_x2),
    .hurtbox_y1(hurtbox_y1),
    .hurtbox_y2(hurtbox_y2),
    .hitbox_active(hitbox_active),
    .hurtbox_active(hurtbox_active)
);
  
Sprite_Boxes #(.IS_MIRRORED(1)) boxes2 (
    .state(sprite_state_p2),
    .sprite_x(sprite_x_p2),
    .sprite_y(sprite_y_p2),
    .hitbox_x1(hitbox_x1_p2),
    .hitbox_x2(hitbox_x2_p2),
    .hitbox_y1(hitbox_y1_p2),
    .hitbox_y2(hitbox_y2_p2),
    .hurtbox_x1(hurtbox_x1_p2),
    .hurtbox_x2(hurtbox_x2_p2),
    .hurtbox_y1(hurtbox_y1_p2),
    .hurtbox_y2(hurtbox_y2_p2),
    .hitbox_active(hitbox_active_p2),
    .hurtbox_active(hurtbox_active_p2)
);

// Player 1 attacks player 2
Collision_Logic col_p1_hits_p2 (
    .attacker_hitbox_x1(hitbox_x1),
    .attacker_hitbox_x2(hitbox_x2),
    .attacker_hitbox_y1(hitbox_y1),
    .attacker_hitbox_y2(hitbox_y2),
    .attacker_hitbox_active(hitbox_active),
    .attacker_attack_flag(attack_flag),
    .attacker_diratk_flag(directional_attack_flag),

    .target_hurtbox_x1(hurtbox_x1_p2),
    .target_hurtbox_x2(hurtbox_x2_p2),
    .target_hurtbox_y1(hurtbox_y1_p2),
    .target_hurtbox_y2(hurtbox_y2_p2),
    .target_hurtbox_active(hurtbox_active_p2),
    .target_is_blocking(is_blocking_p2),

    .got_hit_target(got_hit_p2),
    .got_blocked_target(got_blocked_p2)
);


// Player 2 attacks player 1
Collision_logic col_p2_hits_p1 (
    .attacker_hitbox_x1(hitbox_x1_p2),
    .attacker_hitbox_x2(hitbox_x2_p2),
    .attacker_hitbox_y1(hitbox_y1_p2),
    .attacker_hitbox_y2(hitbox_y2_p2),
    .attacker_hitbox_active(hitbox_active_p2),
    .attacker_attack_flag(attack_flag_p2),
    .attacker_diratk_flag(directional_attack_flag_p2),

    .target_hurtbox_x1(hurtbox_x1),
    .target_hurtbox_x2(hurtbox_x2),
    .target_hurtbox_y1(hurtbox_y1),
    .target_hurtbox_y2(hurtbox_y2),
    .target_hurtbox_active(hurtbox_active),
    .target_is_blocking(is_blocking_p1),

    .got_hit_target(got_hit_p1),
    .got_blocked_target(got_blocked_p1)
);



vga_driver vga(
	.clock(clk_25MHz),
        .reset(1'b0),
	.color_in(color_out),
	.next_x(pixel_x),
	.next_y(pixel_y),
	.hsync(VGA_HS),
	.vsync(VGA_VS),
	.red(VGA_R),
	.green(VGA_G),
	.blue(VGA_B),
	.sync(VGA_SYNC_N),
	.clk(VGA_CLK),
	.blank(VGA_BLANK_N)
);

endmodule
